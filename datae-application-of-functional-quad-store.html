<h1 id="datae-an-application-of-versioned-quad-store">datae: an application of versioned quad store</h1>
<figure>
<img src="https://raw.githubusercontent.com/awesome-data-distribution/datae/master/data.jpg" alt="data" /><figcaption>data</figcaption>
</figure>
<h2 id="author">Author</h2>
<p>Amirouche Boubekki</p>
<h2 id="abstract">Abstract</h2>
<p>datae is web application that is (mostly) implemented with Scheme programming language. It is supported by a database that is a quad store versioned in a direct-acyclic-graph. It is possible to do time traveling queries at any point in history while still being efficient to query and modify the latest version of the data when snapshots are used. The versioned quad store is implemented using a novel approach dubbed generic n-tuple store. datae application goal is to demonstrate that versioned databases allow to implement workflows that ease cooperation.</p>
<h2 id="keywords">Keywords</h2>
<ul>
<li>data management system</li>
<li>data science</li>
<li>distributed version control system</li>
<li>knowledge base</li>
<li>open data</li>
<li>quality assurance</li>
<li>reproducible science</li>
<li>scheme programming language</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Versioning in production systems is a trick everybody knows about whether it is through backup, logging systems and ad-hoc audit trails. It allows to inspect, debug and in worst cases rollback to previous states. There is not need to explain the great importance of versioning in software management as tools like mercurial, git and fossil have shaped modern computing. Having the power of multiple branch versioning open the door to manyfold applications. It allows to implement a mechanic similar to github’s pull requests and gitlab’s merge requests in many domains. That very mechanic is explicit about the actual human workflow in entreprise settings in particular when a senior person validates a change by a less senior person.</p>
<p>The versioned quad store make the implementation of such mechanics more systematic and less error prone as the implementation can be shared across various tools and organisations.</p>
<p>datae takes the path of versioning data and apply the pull request mechanic to collaborate around the making of a knowledge base, similar in spirit to wikidata and inspired from existing data management systems like CKAN.</p>
<p>The use of a version control system to store open data is a good thing as it draws a clear path for reproducible science. But none, meets all the expectations. datae aims to replace the use of git and make practical cooperation around the creation, publication, storage, re-use and maintenance of knowledge bases that are possibly bigger than memory. Resource Description Framework (RDF) offers a good canvas for cooperation around open data but there is no solution that is good enough according to Canova et al. [1]</p>
<p>[1] <a href="https://core.ac.uk/download/pdf/76527782.pdf">Collaborative Open Data versioning: a pragmatic approach using Linked Data</a></p>
<p>datae use a novel approach to store quads in an ordered key-value store. It use WiredTiger database storage engine to deliver a pragmatic versatile ACID-compliant versioned quad store. It also rely on a new algorithm to query versioned tuples based on a topological graph ordering of changes. datae only stores changes between versions. datae does not rely on the theory of patches introduced by Darcs but re-use some its vocabulary.</p>
<p>The first part will present some background knowledge, the second part will describe the implementation, the next part will present benchmarks and at last we will conclude with summary of the work and what remains to be explored.</p>
<h2 id="background">Background</h2>
<p>This section will describe a few concept upon which datae is built or take inspiration.</p>
<h3 id="resource-description-framework">Resource Description Framework</h3>
<p><a href="https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">RDF</a> is World Wide Web Consortium (W3C) set of standards that aims to facilitating cooperation around data by specifying several tools. Among other things it specified means to exchange, query and somewhat how to store data. datae only takes inspiration from this standards. It doesn’t forcefully implement (for the time being) the different RDF specifications (that are by the way in the process of a rework). datae takes what is good and leave aside what is not.</p>
<p>The following sections dive into several part of the RDF framework and explain how they relate to datae.</p>
<h4 id="sparql">SPARQL</h4>
<p>SPARQL is a query language part of RDF that specify the language that must be used by RDF databases to store and query data. It also provides ways to do federated queries. That is, queries across several databases. Like it is explained in the literature SPARQL can be difficult at times to implement . Instead of aiming for direct interoperability, datae take the stance to primarly deliver its main feature that is <em>cooperation around the making of knowledge bases</em>. The main drawback could be that the learning curve to join the datae party could be more steep. But that is not the case, for two reasons: a) datae internal query language is similar in principle to SPARQL even if it is not exact same syntax b) the primary user interface of data is not SPARQL. Instead, the interact with datae, an user will rely on an graphical user interface or command line tool to upload and download a given version of some data. For some advanced use cases a subset of SPARQL will be available.</p>
<p>SPARQL specify various data types based on XML specification. datae doesn’t conform to that specification. Instead, datae can store anything that has a JSON representation which is superset of RDF base data types.</p>
<h4 id="vocabularies-ontologies-and-linked-data">Vocabularies, Ontologies and Linked Data</h4>
<p>With RDF comes a specification to describe the content of a database. For instance, the <a href="https://github.com/inspire-eu-rdf">INSPIRE</a> initiative is an interesting project that aims that standarzing across organisation a vocabulary to exchange spatial data. There is many competing vocabulary.</p>
<p>Settling on particular vocabulary is not necessary and the choice of a vocabulary can be made later.</p>
<h3 id="version-control-system">Version Control System</h3>
<p>datae is about versioning data. That is keeping a record of how the data looks like in a very precise way and how it evolves over time. It also about exchanging data. Not just querying remote databases, but getting the actual data locally to be able to fix it, refine it, improve it and more generally collaborate.</p>
<p>In general, a VCS is a particular system that draws a canvas for collaboration around the making of software products. VCS are things like git, mercurial and fossil. That said, it is not the only instances of versioning in the wild. There is also wikis! And among them there is wikibase the software that sports wikidata.</p>
<p>Compared to git, mercurial or fossil, datae aims to achieve a very similar user-experience. That is commit-push-pull mechanic and the, so called, pull requests. The problem with git, in particular, because it is the main competitor, is that it doesn’t support well bigger than memory data. Otherwise said, it is bad at handling large datasets. Unlike git, datae handles bigger than RAM structured data. This made possible thanks to WiredTiger which is a real database. WiredTiger is a database engine that is widespread in the industry. It is used at MongoDB and Amazon.</p>
<p>Compared to wikibase and wikidata, datae aims to be much more easy to setup and operate. To achieve something similar to datae, one need both to setup wikibase with MySQL to allow edition and store history and blazegraph to do querying. datae will simplify collaboration around the making of large knowledge bases.</p>
<p>datae is collaboration tool that is a mix a of git and wikibase. Like git, it is portable, easy to setup. Like wikibase, it allows to edit and query efficently structured data.</p>
<h3 id="ordered-key-value-store">Ordered Key-Value Store</h3>
<p>Key-value stores offers a rather high level primitive to build high performance, multi-model and domain specific databases. The common denominator of key-value stores is that they are mappings of bytes where keys are always sorted in the lexicographic order. Even if they do not all expose a cursor interface, they certainly allow movements inside the mapping or range queries (also known as slices).</p>
<p>Nowdays there is numerous libraries offering a similar interface among them there is FoundationDB. Similar software include Tokyo Cabinet, Kyoto Cabinet, LMDB, LevelDB and RocksDB. They offer different trade-offs and features. datae use WiredTiger because it is not a bad choice. It performs well on some benchmarks [2]. It takes in charge the difficult matter of guaranting Atomicity, Consistency, Isolation and Durability (ACID) and also handle in-memory caching. WiredTiger is the component that allows to build a durable version control system for bigger than memory datasets.</p>
<p>[2] http://www.lmdb.tech/bench/ondisk/</p>
<h3 id="scheme-programming-language">Scheme Programming Language</h3>
<p>According to Wikipedia:</p>
<blockquote>
<p>Scheme is a programming language that supports multiple paradigms, including functional and imperative programming. It is one of the three main dialects of Lisp, alongside Common Lisp and Clojure. Unlike Common Lisp, Scheme follows a minimalist design philosophy, specifying a small standard core with powerful tools for language extension.</p>
</blockquote>
<p>High-level languages like Scheme are not the prefered tools to build database abstraction, so far. That said, some had success with Java, Go and Clojure [3]. With the advent of ordered key-value stores the situation is different. Key-value stores solve the performance problems while Scheme allows to express quickly high level abstractions that fit exactly the domain problem.</p>
<p>[3] https://docs.datomic.com/</p>
<p>Chez Scheme is (prolly) the fatest Scheme implementation [4] and in particular it is faster than Racket [5]. Which makes Chez probably the fastest dynamic language in the known Universe. Scheme community has good scientifical culture. It has been the inspiration that allowed datae to take the current form.</p>
<p>[4] https://ecraven.github.io/r7rs-benchmarks/</p>
<p>[5] https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/racket-python3.html</p>
<h2 id="implementation">Implementation</h2>
<p>In the spirit of Scheme programming language, datae try to solve the problem using a minimalist core of powerful primitives upon which one can build abstractions to solve bigger problems. The generic n-tuple store is such an abstraction. It allows to take advantage of WiredTiger without scarifying expressiveness. Generic n-tuple store is a set of procedures that generalize triple and quad store respectively 3-tuples and 4-tuples to n-tuples. In turn, it allows to share code to implement the versioned database to represent its components:</p>
<ul>
<li>The repository metadata as a 4-tuple store,</li>
<li>the versioned quads as a 6-tuple store,</li>
<li>and the 4-tuple stores that are snapshots of branches.</li>
</ul>
<p>That section is split into four parts. The first part is a tentative formalisation of the problem of finding a smallest set of indices that allows to bind any pattern in one hop to implement the generic tuple store. The third part will dive into the specifics of the implementation of versioned 4-tuples using the generic n-tuple store and how the concept of history significance makes querying versioned tuples in a direct-acyclic-graph algorithmically less complex. The fourth and last part of this section explain how to model various datastructures in terms of quads to take advantage of versioning.</p>
<h3 id="generic-n-tuple-store">Generic n-tuple store</h3>
<p>The literature seems to be void from attempts to build tuple stores based on Ordered Key-Value store. Even if similar work exsists like hexastore they don’t try to generalize the concept of triple and quad store so that it possible to create a database that can host tuple of n items.</p>
<p>Given a 4-tuple store:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb1-1" data-line-number="1">(<span class="kw">define</span><span class="fu"> quadstore </span>(nstore engine prefix &#39;(collection uid key value)))</a></code></pre></div>
<p>We need to bind any pattern in one hop. That is, the following query:</p>
<pre><code>(nstore-select (nstore-from &#39;blog (nstore-var &#39;uid) &#39;title (nstore-var &#39;title)))</code></pre>
<p>Will return:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb3-1" data-line-number="1">((uid . P4X432) (title . <span class="st">&quot;hyper.dev&quot;</span>))</a></code></pre></div>
<p>It is possible to do that with a single query using and an index that is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb4-1" data-line-number="1">(collection key uid value)</a></code></pre></div>
<p>But the following index is also valid:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb5-1" data-line-number="1">(collection key value uid)</a></code></pre></div>
<p>We could consider every permutation of the <code>(collection uid key value)</code> tuple as indices but it counts as 24 indices which would translate into 24 times the size of the original data. Whereas there is an algorithm that provides an optimal solution that only requires 6 permutations (instead of 24) in the case of 4-tuple store and 20 permutations (instead of 720) in the case of 6-tuple store.</p>
<p>The problem was stated on <a href="https://math.stackexchange.com/q/3146568/23663">math.stackexchange.com</a>. Two answers were provided including an algorithm that allows to compute the minimal set of indices allowing to query any pattern in one hop.</p>
<p><strong>Note:</strong> we only consider the case where the pattern is bound in one hop because otherwise it would require two or more database calls which are more costly. We trade some space on disk, to avoid to ask the database engine another join that is expensive. Building a generic n-tuple store database without that constraint was not tried. Also downstream the code for querying is more complex.</p>
<p>Here is the algorithm to compute the minimal set of permutations that allows to bind any pattern in one hop:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb6-1" data-line-number="1">    (<span class="kw">define</span><span class="fu"> </span>(permutation-prefix? c o)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">      (any (<span class="kw">lambda</span> (p) (prefix? p o)) (permutations c)))</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    (<span class="kw">define</span><span class="fu"> </span>(ok? combinations candidate)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">      (every (<span class="kw">lambda</span> (c) (any (<span class="kw">lambda</span> (p) (permutation-prefix? c p)) candidate))</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">             combinations))</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    (<span class="kw">define</span><span class="fu"> </span>(findij L)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">      (<span class="kw">let</span> loop3 ((x L)</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">                  (y &#39;()))</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">        (<span class="kw">if</span> (<span class="kw">or</span> (<span class="kw">null?</span> x) (<span class="kw">null?</span> (<span class="kw">cdr</span> x)))</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">            (<span class="kw">values</span> <span class="dv">#f</span> (<span class="kw">append</span> (reverse! y) x) <span class="dv">#f</span> <span class="dv">#f</span>)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">            (<span class="kw">if</span> (<span class="kw">and</span> (<span class="kw">not</span> (<span class="kw">cdr</span> (<span class="kw">list-ref</span> x <span class="dv">0</span>))) (<span class="kw">cdr</span> (<span class="kw">list-ref</span> x <span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">                (<span class="kw">values</span> <span class="dv">#t</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">                        (<span class="kw">append</span> (<span class="kw">cddr</span> x) (reverse! y))</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">                        (<span class="kw">car</span> (<span class="kw">list-ref</span> x <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">                        (<span class="kw">car</span> (<span class="kw">list-ref</span> x <span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">                (loop3 (<span class="kw">cdr</span> x) (<span class="kw">cons</span> (<span class="kw">car</span> x) y))))))</a>
<a class="sourceLine" id="cb6-19" data-line-number="19"></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    (<span class="kw">define</span><span class="fu"> </span>(bool v)</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">      (<span class="kw">not</span> (<span class="kw">not</span> v)))</a>
<a class="sourceLine" id="cb6-22" data-line-number="22"></a>
<a class="sourceLine" id="cb6-23" data-line-number="23">    (<span class="kw">define</span><span class="fu"> </span>(lex&lt; a b)</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">      (<span class="kw">let</span> loop ((a a)</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">                 (b b))</a>
<a class="sourceLine" id="cb6-26" data-line-number="26">        (<span class="kw">if</span> (<span class="kw">null?</span> a)</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">            <span class="dv">#t</span></a>
<a class="sourceLine" id="cb6-28" data-line-number="28">            (<span class="kw">if</span> (<span class="kw">not</span> (<span class="kw">=</span> (<span class="kw">car</span> a) (<span class="kw">car</span> b)))</a>
<a class="sourceLine" id="cb6-29" data-line-number="29">                (<span class="kw">&lt;</span> (<span class="kw">car</span> a) (<span class="kw">car</span> b))</a>
<a class="sourceLine" id="cb6-30" data-line-number="30">                (loop (<span class="kw">cdr</span> a) (<span class="kw">cdr</span> b))))))</a>
<a class="sourceLine" id="cb6-31" data-line-number="31"></a>
<a class="sourceLine" id="cb6-32" data-line-number="32">    (<span class="kw">define</span><span class="fu"> </span>(make-indices n)</a>
<a class="sourceLine" id="cb6-33" data-line-number="33">      (<span class="kw">let*</span> ((tab (iota n))</a>
<a class="sourceLine" id="cb6-34" data-line-number="34">             (cx (combination (<span class="kw">floor</span> (<span class="kw">/</span> n <span class="dv">2</span>)) tab)))</a>
<a class="sourceLine" id="cb6-35" data-line-number="35">        (<span class="kw">let</span> loop1 ((cx cx)</a>
<a class="sourceLine" id="cb6-36" data-line-number="36">                    (out &#39;()))</a>
<a class="sourceLine" id="cb6-37" data-line-number="37">          (<span class="kw">if</span> (<span class="kw">null?</span> cx)</a>
<a class="sourceLine" id="cb6-38" data-line-number="38">              (<span class="kw">begin</span> (assert (ok? (combinations tab) out))</a>
<a class="sourceLine" id="cb6-39" data-line-number="39">                     (sort! lex&lt; out))</a>
<a class="sourceLine" id="cb6-40" data-line-number="40">              (<span class="kw">let</span> loop2 ((L (map (<span class="kw">lambda</span> (i) (<span class="kw">cons</span> i (bool (<span class="kw">memv</span> i (<span class="kw">car</span> cx))))) tab))</a>
<a class="sourceLine" id="cb6-41" data-line-number="41">                          (a &#39;())</a>
<a class="sourceLine" id="cb6-42" data-line-number="42">                          (b &#39;()))</a>
<a class="sourceLine" id="cb6-43" data-line-number="43">                (<span class="kw">call-with-values</span> (<span class="kw">lambda</span> () (findij L))</a>
<a class="sourceLine" id="cb6-44" data-line-number="44">                  (<span class="kw">lambda</span> (continue? L i j)</a>
<a class="sourceLine" id="cb6-45" data-line-number="45">                    (<span class="kw">if</span> continue?</a>
<a class="sourceLine" id="cb6-46" data-line-number="46">                        (loop2 L (<span class="kw">cons</span> j a) (<span class="kw">cons</span> i b))</a>
<a class="sourceLine" id="cb6-47" data-line-number="47">                        (loop1 (<span class="kw">cdr</span> cx)</a>
<a class="sourceLine" id="cb6-48" data-line-number="48">                               (<span class="kw">cons</span> (<span class="kw">append</span> (reverse! a) (map <span class="kw">car</span> L) (reverse! b))</a>
<a class="sourceLine" id="cb6-49" data-line-number="49">                                     out))))))))))</a></code></pre></div>
<h3 id="quad-store-versioned-in-a-direct-acyclic-graph">Quad store versioned in a direct-acyclic-graph</h3>
<h4 id="history-significance">History Significance</h4>
<p>Merge commits will resolve conflicts in a way that makes it possible to define a history significance measure that allows to linearize with a topological sort the direct-acyclic-graph of changes.</p>
<h3 id="how-to-model-data">How to model data?</h3>
<h4 id="versioned-tabular-data">Versioned Tabular Data</h4>
<p>Frictionless data: https://frictionlessdata.io/data-packages/</p>
<h4 id="linux-kernels-git-repository">Linux kernel’s git repository</h4>
<h4 id="wikidata">Wikidata</h4>
<h4 id="versioned-hackernews">Versioned hackernews</h4>
<p>http://news.ycombinator.com/</p>
<h2 id="benchmarks">Benchmarks</h2>
<h3 id="versioned-tabular-data-1">Versioned Tabular Data</h3>
<h3 id="wikidata-1">Wikidata</h3>
<h3 id="versioned-hackernews-1">Versioned hackernews</h3>
<h2 id="annexes">Annexes</h2>
<h3 id="srfi-167-ordered-key-value-store">SRFI-167: Ordered key-value store</h3>
<p><a href="https://srfi.schemers.org/srfi-167/" class="uri">https://srfi.schemers.org/srfi-167/</a></p>
<h3 id="srfi-168-generic-n-tuple-store">SRFI-168: Generic n-tuple store</h3>
<p><a href="https://srfi.schemers.org/srfi-168/" class="uri">https://srfi.schemers.org/srfi-168/</a></p>
<h3 id="functional-quad-store">Functional quad store</h3>
