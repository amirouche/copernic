<h1 id="datae-an-application-of-versioned-quadstore">datae: an application of versioned quadstore</h1>
<figure>
<img src="https://raw.githubusercontent.com/awesome-data-distribution/datae/master/data.jpg" alt="data" /><figcaption>data</figcaption>
</figure>
<h2 id="author">Author</h2>
<p>Amirouche Boubekki</p>
<h2 id="abstract">Abstract</h2>
<p>datae is web application that is (mostly) implemented with Scheme programming language. It is supported by an versioned database that is a quadstore versioned in a direct-acyclic-graph. It is possible to do queries at any point in history while still being efficient to do queries and modify the latest version of the data when snapshots are used. The versioned quadstore is implemented using a novel approach dubbed generic tuple store. datae application goal is to demonstrate that versioned databases allow to implement workflows that ease cooperation.</p>
<h2 id="keywords">Keywords</h2>
<ul>
<li>data management system</li>
<li>data science</li>
<li>distributed version control system</li>
<li>knowledge base</li>
<li>open data</li>
<li>quality assurance</li>
<li>reproducible science</li>
<li>scheme programming language</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Versioning in production systems is a trick everybody knows about whether it is through backup, logging systems and ad-hoc audit trails. It allows to inspect, debug and in worst cases rollback to previous states. There is not need to explain the great importance of versioning in software management as tools like mercurial, git and fossil have shaped modern computing. Having the power of multiple branch versioning open the door to manyfold applications. It allows to implement a mechanic similar to gitlab’s merge requests in any domains. That very mechanic is explicit about the actual human workflow in entreprise settings in particular when seniors validate changes by less senior persons.</p>
<p>The versioned quadstore make the implementation of such mechanics more systematic and less error prone as the implementation can be shared across various tools and organisations.</p>
<p>The use of a version control system to store open data is a good thing as it draws a clear path for reproducible science. But none, meets all the expectations. datae aims to replace the use of git and make practical cooperation around the creation, publication, storage, re-use and maintenance of knowledge bases that are possibly bigger than memory.</p>
<p>Resource Description Framework (RDF) offers a good canvas for cooperation around open data but there is no solution that is good enough. [1] (TODO: explain what are those features required for cooperation and why those features are important.) (TODO: cite an article about the importance of git and git hosting solutions in the context of software development). datae use a novel approach to query versioned data based on a topological graph ordering of changes. datae only stores changes between versions. datae does not rely on the Theory of Patches introduced by Darcs but re-use some its vocabulary. datae use WiredTiger database storage engine, an ordered key-value store, to deliver a pragmatic ACID-compliant versioned quadstore.</p>
<p>[1]</p>
<p>The first part will present some background knowledge, the second part will describe the implementation, the next part will present benchmarks and at last we will conclude with summary of the work and what remains to be explored.</p>
<h2 id="background">Background</h2>
<h3 id="resource-description-framework">Resource Description Framework</h3>
<h4 id="linked-data">Linked Data</h4>
<h4 id="tripe-and-quad-store">Tripe and Quad Store</h4>
<h4 id="sparql">SPARQL</h4>
<h3 id="version-control-system">Version Control System</h3>
<h4 id="git-mercurial-and-fossil">git, mercurial and fossil</h4>
<h4 id="wikibase-and-wikidata">Wikibase and Wikidata</h4>
<h3 id="ordered-key-value-store">Ordered Key-Value Store</h3>
<p>Key-value stores offers a rather high level primitive to build high performance, multi-model and domain specific databases. The common denominator of key-value stores is that they are mappings of bytes where keys are always in the lexicographic order. Even if they do not all expose a cursor interface, they certainly allow movements inside the mapping or prefix range queries (also known as slices).</p>
<p>Nowdays there is numerous libraries offering a similar interface among them there is FoundationDB. Similar software include Tokyo Cabinet, Kyoto Cabinet, LMDB, LevelDB and RocksDB. They offer different trade-offs and features. datae use WiredTiger because it is not a bad choice. It performs well on some benchmarks [2]. It takes in charge the difficult matter of guaranting Atomicity, Consistency, Isolation and Durability (ACID) and also handle in-memory caching. WiredTiger is the component that allows to build a durable version control system for bigger than memory datasets.</p>
<p>[2] http://www.lmdb.tech/bench/ondisk/</p>
<h3 id="scheme-programming-language">Scheme Programming Language</h3>
<p>According to Wikipedia:</p>
<blockquote>
<p>Scheme is a programming language that supports multiple paradigms, including functional and imperative programming. It is one of the three main dialects of Lisp, alongside Common Lisp and Clojure. Unlike Common Lisp, Scheme follows a minimalist design philosophy, specifying a small standard core with powerful tools for language extension.</p>
</blockquote>
<p>High-level languages like Scheme are not the prefered tools to build database abstraction, so far. That said, some had success with Java, Go and Clojure [3]. With the advent of ordered key-value stores the situation is different. Key-value stores solve the performance problems while Scheme allows to express quickly high level abstractions that fit exactly the domain problem.</p>
<p>[3] https://docs.datomic.com/</p>
<p>Chez Scheme is (prolly) the fatest Scheme implementation [4] and in particular it is faster than Racket [5]. Which makes Chez probably the fastest dynamic language in the known Universe. Scheme community has good scientifical culture. It has been the inspiration that allowed datae to take the current form.</p>
<p>[4] https://ecraven.github.io/r7rs-benchmarks/ [5] https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/racket-python3.html</p>
<h2 id="implementation">Implementation</h2>
<p>In the spirit of Scheme programming language, datae try to solve the problem using a minimalist core of powerful primitives upon which one can build abstractions to solve bigger problems. The generic tuple store is such an abstraction. It allows to take advantage of WiredTiger without scarifying expressiveness. Generic Tuple Store is a set of procedures that generalize triple and quad store respectively 3-tuples and 4-tuples to n-tuples. In turn, it allows to share code to implement the versioned database to represent its components:</p>
<ul>
<li>The repository metadata as a 3-tuple store,</li>
<li>the versioned quads as a 6-tuple store,</li>
<li>and the 4-tuple stores that are snapshots of branches</li>
</ul>
<p>That section is split into four parts. The first part is a tentative formalisation of the problem of finding a smallest table set that allows to bind any pattern in one hop to implement the generic tuple store. The third part will dive into the specifics of the implementation of versioned 4-tuples using the generic store and how the concept of history significance makes querying versioned tuples in a direct-acyclic-graph algorithmically less complex. The fourth and last part of this section explain how to model various datastructures in terms of quads to take advantage of versioning.</p>
<h3 id="generic-tuple-store">Generic Tuple Store</h3>
<p>The literature seems to be void from attempts to build tuple stores based on Ordered Key-Value store. Even if similar work exsists like hexastore they don’t try to generalize the concept of triple and quad store so that it possible to create a database that can host tuple of n items where n is bigger than 3.</p>
<p>Given a 4-tuple store:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb1-1" data-line-number="1">(<span class="kw">define</span><span class="fu"> store </span>(nstore engine &#39;(collection uid key value)))</a></code></pre></div>
<p>We need to bind any pattern in one hop. That is for instance the following query:</p>
<pre><code>(select (from &#39;blog (var &#39;uid) &#39;title (var &#39;title)))</code></pre>
<p>Will return:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb3-1" data-line-number="1">((uid . P4X432) (title . <span class="st">&quot;hyper.dev&quot;</span>))</a></code></pre></div>
<p>It is possible to do that with a single query using and an index that is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb4-1" data-line-number="1">(collection key uid value)</a></code></pre></div>
<p>But the following index is also valid:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb5-1" data-line-number="1">(collection key value uid)</a></code></pre></div>
<p>We could consider every permutation of the <code>(collection uid key value)</code> tuple as indices but it counts as 24 indices which would translate into 24 times the size of the original data. Whereas there is an algorithm that provides an optimal solution that only requires 6 permutations (instead of 24) in the case of 4-tuple store and 20 permutations (instead of 720) in the case of 6-tuple store.</p>
<p>The problem was stated on <a href="https://math.stackexchange.com/q/3146568/23663">math.stackexchange.com</a>. Two answers were provided including an algorithm that allows to compute the minimal set of indices that allows to query any pattern in one hop.</p>
<p><strong>Note:</strong> we only consider the case where the pattern is bound in one hop because otherwise it would require two or more database calls which are more costly. We trade some space on disk, to avoid to ask the database engine another join that could be expensive. Building a generic tuple store database without that constraint was not tried but it seems like downstream the code for querying is also more complex.</p>
<p>Here is the algorithm to compute the minimal set of permutations that allows to bind any pattern in one hop:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb6-1" data-line-number="1">    (<span class="kw">define</span><span class="fu"> </span>(permutation-prefix? c o)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">      (any (<span class="kw">lambda</span> (p) (prefix? p o)) (permutations c)))</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    (<span class="kw">define</span><span class="fu"> </span>(ok? combinations candidate)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">      (every (<span class="kw">lambda</span> (c) (any (<span class="kw">lambda</span> (p) (permutation-prefix? c p)) candidate))</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">             combinations))</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    (<span class="kw">define</span><span class="fu"> </span>(findij L)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">      (<span class="kw">let</span> loop3 ((x L)</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">                  (y &#39;()))</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">        (<span class="kw">if</span> (<span class="kw">or</span> (<span class="kw">null?</span> x) (<span class="kw">null?</span> (<span class="kw">cdr</span> x)))</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">            (<span class="kw">values</span> <span class="dv">#f</span> (<span class="kw">append</span> (reverse! y) x) <span class="dv">#f</span> <span class="dv">#f</span>)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">            (<span class="kw">if</span> (<span class="kw">and</span> (<span class="kw">not</span> (<span class="kw">cdr</span> (<span class="kw">list-ref</span> x <span class="dv">0</span>))) (<span class="kw">cdr</span> (<span class="kw">list-ref</span> x <span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">                (<span class="kw">values</span> <span class="dv">#t</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">                        (<span class="kw">append</span> (<span class="kw">cddr</span> x) (reverse! y))</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">                        (<span class="kw">car</span> (<span class="kw">list-ref</span> x <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">                        (<span class="kw">car</span> (<span class="kw">list-ref</span> x <span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">                (loop3 (<span class="kw">cdr</span> x) (<span class="kw">cons</span> (<span class="kw">car</span> x) y))))))</a>
<a class="sourceLine" id="cb6-19" data-line-number="19"></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    (<span class="kw">define</span><span class="fu"> </span>(bool v)</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">      (<span class="kw">not</span> (<span class="kw">not</span> v)))</a>
<a class="sourceLine" id="cb6-22" data-line-number="22"></a>
<a class="sourceLine" id="cb6-23" data-line-number="23">    (<span class="kw">define</span><span class="fu"> </span>(lex&lt; a b)</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">      (<span class="kw">let</span> loop ((a a)</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">                 (b b))</a>
<a class="sourceLine" id="cb6-26" data-line-number="26">        (<span class="kw">if</span> (<span class="kw">null?</span> a)</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">            <span class="dv">#t</span></a>
<a class="sourceLine" id="cb6-28" data-line-number="28">            (<span class="kw">if</span> (<span class="kw">not</span> (<span class="kw">=</span> (<span class="kw">car</span> a) (<span class="kw">car</span> b)))</a>
<a class="sourceLine" id="cb6-29" data-line-number="29">                (<span class="kw">&lt;</span> (<span class="kw">car</span> a) (<span class="kw">car</span> b))</a>
<a class="sourceLine" id="cb6-30" data-line-number="30">                (loop (<span class="kw">cdr</span> a) (<span class="kw">cdr</span> b))))))</a>
<a class="sourceLine" id="cb6-31" data-line-number="31"></a>
<a class="sourceLine" id="cb6-32" data-line-number="32">    (<span class="kw">define</span><span class="fu"> </span>(make-indices n)</a>
<a class="sourceLine" id="cb6-33" data-line-number="33">      (<span class="kw">let*</span> ((tab (iota n))</a>
<a class="sourceLine" id="cb6-34" data-line-number="34">             (cx (combination (<span class="kw">floor</span> (<span class="kw">/</span> n <span class="dv">2</span>)) tab)))</a>
<a class="sourceLine" id="cb6-35" data-line-number="35">        (<span class="kw">let</span> loop1 ((cx cx)</a>
<a class="sourceLine" id="cb6-36" data-line-number="36">                    (out &#39;()))</a>
<a class="sourceLine" id="cb6-37" data-line-number="37">          (<span class="kw">if</span> (<span class="kw">null?</span> cx)</a>
<a class="sourceLine" id="cb6-38" data-line-number="38">              (<span class="kw">begin</span> (assert (ok? (combinations tab) out))</a>
<a class="sourceLine" id="cb6-39" data-line-number="39">                     (sort! lex&lt; out))</a>
<a class="sourceLine" id="cb6-40" data-line-number="40">              (<span class="kw">let</span> loop2 ((L (map (<span class="kw">lambda</span> (i) (<span class="kw">cons</span> i (bool (<span class="kw">memv</span> i (<span class="kw">car</span> cx))))) tab))</a>
<a class="sourceLine" id="cb6-41" data-line-number="41">                          (a &#39;())</a>
<a class="sourceLine" id="cb6-42" data-line-number="42">                          (b &#39;()))</a>
<a class="sourceLine" id="cb6-43" data-line-number="43">                (<span class="kw">call-with-values</span> (<span class="kw">lambda</span> () (findij L))</a>
<a class="sourceLine" id="cb6-44" data-line-number="44">                  (<span class="kw">lambda</span> (continue? L i j)</a>
<a class="sourceLine" id="cb6-45" data-line-number="45">                    (<span class="kw">if</span> continue?</a>
<a class="sourceLine" id="cb6-46" data-line-number="46">                        (loop2 L (<span class="kw">cons</span> j a) (<span class="kw">cons</span> i b))</a>
<a class="sourceLine" id="cb6-47" data-line-number="47">                        (loop1 (<span class="kw">cdr</span> cx)</a>
<a class="sourceLine" id="cb6-48" data-line-number="48">                               (<span class="kw">cons</span> (<span class="kw">append</span> (reverse! a) (map <span class="kw">car</span> L) (reverse! b))</a>
<a class="sourceLine" id="cb6-49" data-line-number="49">                                     out))))))))))</a></code></pre></div>
<h3 id="quadstore-versioned-in-a-direct-acyclic-graph">Quadstore versioned in a direct-acyclic-graph</h3>
<h4 id="history-significance">History Significance</h4>
<p>Merge commits will resolve conflicts in a way that makes it possible to define a history significance measure that allows to linearize with a topological sort the direct-acyclic-graph of changes. Without that, querying versions at any point is not pratical as seen in the litterature [x].</p>
<p>[x]</p>
<h3 id="how-to-model-data">How to model data?</h3>
<h4 id="versioned-tabular-data">Versioned Tabular Data</h4>
<p>Frictionless data.</p>
<h4 id="git-kernel">Git Kernel</h4>
<p>OK</p>
<h4 id="wikidata">Wikidata</h4>
<p>TODO</p>
<h4 id="versioned-hacker-new">Versioned Hacker New</h4>
<p>TODO?</p>
<h2 id="benchmark">Benchmark</h2>
<h3 id="git">Git</h3>
<h3 id="versioned-hackernews">Versioned HackerNews</h3>
<h2 id="annexe">Annexe</h2>
<h3 id="versioned-quadstore-reference">versioned quadstore reference</h3>
<h4 id="make-.-config"><code>(make . config)</code></h4>
<h4 id="close-.-database"><code>(close . database)</code></h4>
<h4 id="metadata-database"><code>(metadata database)</code></h4>
<h4 id="merge-database-branch-other"><code>(merge! database branch other)</code></h4>
<h4 id="reverse-database-revision"><code>(reverse! database revision)</code></h4>
<h4 id="make-branch-database-name-revision-snapshot"><code>(make-branch! database name revision snapshot?)</code></h4>
<h4 id="snapshot-database-branch"><code>(snapshot! database branch)</code></h4>
<h4 id="transactional-proc-procedure"><code>(transactional proc) → procedure</code></h4>
<h4 id="branch-transaction-name"><code>(branch transaction name)</code></h4>
<h4 id="ask-transaction-revision-collection-uid-key-value"><code>(ask? transaction revision collection uid key value)</code></h4>
<h4 id="add-transaction-revision-collection-uid-key-value"><code>(add transaction revision collection uid key value)</code></h4>
<h4 id="rm-transaction-revision-collection-uid-key-value"><code>(rm transaction revision collection uid key value)</code></h4>
